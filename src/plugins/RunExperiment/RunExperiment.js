/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Wed Mar 02 2016 22:17:40 GMT-0600 (Central Standard Time).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'common/util/ejs', // for ejs templates
    'common/util/xmljsonconverter', // used to save model as json
    'plugin/RunExperiment/RunExperiment/Templates/Templates', // 
    'rosmod/meta',
    'rosmod/remote_utils',
    'rosmod/modelLoader',
    'q'
], function (
    PluginConfig,
    PluginBase,
    ejs,
    Converter,
    TEMPLATES,
    MetaTypes,
    utils,
    loader,
    Q) {
    'use strict';

    /**
     * Initializes a new instance of RunExperiment.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin RunExperiment.
     * @constructor
     */
    var RunExperiment = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.metaTypes = MetaTypes;
        this.FILES = {
            'node_xml': 'node.xml.ejs'
        };
    };

    // Prototypal inheritance from PluginBase.
    RunExperiment.prototype = Object.create(PluginBase.prototype);
    RunExperiment.prototype.constructor = RunExperiment;

    /**
     * Gets the name of the RunExperiment.
     * @returns {string} The name of the plugin.
     * @public
     */
    RunExperiment.prototype.getName = function () {
        return 'RunExperiment';
    };

    /**
     * Gets the semantic version (semver.org) of the RunExperiment.
     * @returns {string} The version of the plugin.
     * @public
     */
    RunExperiment.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    RunExperiment.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;

        // Default fails
        self.result.success = false;

        if (typeof WebGMEGlobal !== 'undefined') {
            callback(new Error('Client-side execution is not supported'), self.result);
            return;
        }
	
        self.updateMETA(self.metaTypes);

	// the active node for this plugin is experiment -> experiments -> project
	var projectNode = self.core.getParent(self.core.getParent(self.activeNode));
	var projectName = self.core.getAttribute(projectNode, 'name');
	self.logger.info('loading project: ' + projectName);
	loader.loadProjectModel(self.core, self.META, projectNode, self.rootNode)
	    .then(function(projectModel) {
		self.projectModel = projectModel;
		self.logger.info('parsed model!');
		// map the containers to hosts (1-1)
		return self.mapContainersToHosts();
	    })
	    .then(function() {
		// generate xml files here
		self.logger.info('generating artifacts');
		return self.generateArtifacts();
	    })
	    .then(function() {
		// send the deployment + binaries off to hosts for execution
		self.logger.info('deploying onto system');
		return self.deployExperiment();
	    })
	    .then(function() {
		// create experiment nodes in the model corresponding to created experiment mapping
		return self.createModelArtifacts();
	    })
	    .then(function() {
		// This will save the changes. If you don't want to save;
		self.logger.info('saving updates to model');
		// exclude self.save and call callback directly from this scope.
		return; // self.save('RunExperiment updated model.');
	    })
	    .then(function (err) {
		if (err) {
		    callback(err, self.result);
		    return;
		}
		self.result.setSuccess(true);
		callback(null, self.result);
	    })
	    .catch(function(err) {
        	self.logger.error(err);
        	self.createMessage(self.activeNode, err, 'error');
		self.result.setSuccess(false);
		callback(err, self.result);
	    })
		.done();
    };

    RunExperiment.prototype.mapContainersToHosts = function () {
	var self = this;

	var expName = self.core.getAttribute(self.activeNode, 'name');
	var expPath = self.core.getPath(self.activeNode);
	var selectedExperiment = self.projectModel.experiments[expName];
	if ( expPath != selectedExperiment.path ) {
	    throw new String("Experiments exist with the same name, can't properly resolve!");
	}
	self.logger.info('Experiment mapping containers in ' + selectedExperiment.deployment.name +
			 ' to hosts in '  + selectedExperiment.system.name);
	var hosts = selectedExperiment.system.hosts;
	var containers = selectedExperiment.deployment.containers;
    };

    RunExperiment.prototype.generateArtifacts = function () {
	/*
	var path = require('path'),
	filendir = require('filendir'),
	filesToAdd = {},
	prefix = 'src/';

	var projectName = self.projectModel.name,

        for (var pkg in self.projectModel.software.packages) {
	    var pkgInfo = self.projectModel.software.packages[pkg],
	    cmakeFileName = prefix + pkgInfo.name + '/CMakeLists.txt',
	    cmakeTemplate = TEMPLATES[self.FILES['cmakelists']];
	    filesToAdd[cmakeFileName] = ejs.render(cmakeTemplate, {'pkgInfo':pkgInfo});

	    var packageXMLFileName = prefix + pkgInfo.name + '/package.xml',
	    packageXMLTemplate = TEMPLATES[self.FILES['package_xml']];
	    filesToAdd[packageXMLFileName] = ejs.render(packageXMLTemplate, {'pkgInfo':pkgInfo});

	    for (var cmp in pkgInfo.components) {
		var compInfo = pkgInfo.components[cmp];
		self.generateComponentFiles(filesToAdd, prefix, pkgInfo, compInfo);
	    }

	    for (var msg in pkgInfo.messages) {
		var msgInfo = pkgInfo.messages[msg],
		msgFileName = prefix + pkgInfo.name + '/msg/' + msgInfo.name + '.msg';
		filesToAdd[msgFileName] = msgInfo.definition;
	    }

	    for (var srv in pkgInfo.services) {
		var srvInfo = pkgInfo.services[srv],
		srvFileName = prefix + pkgInfo.name + '/srv/' + srvInfo.name + '.srv';
		filesToAdd[srvFileName] = srvInfo.definition;
	    }
	}

	var promises = [];

	return (function () {
	    for (var f in filesToAdd) {
		var fname = path.join(self.gen_dir, f),
		data = filesToAdd[f];

		promises.push(new Promise(function(resolve, reject) {
		    filendir.writeFile(fname, data, function(err) {
			if (err) {
			    self.logger.error(err);
			    reject(err);
			}
			else {
			    resolve();
			}
		    });
		}));
	    }
	    return Q.all(promises);
	})()
	    .then(function() {
		self.logger.debug('generated artifacts.');
		self.createMessage(self.activeNode, 'Generated artifacts.');
	    })
	*/
    };

    RunExperiment.prototype.deployExperiment = function () {
    };

    RunExperiment.prototype.createModelArtifacts = function () {
    };

    return RunExperiment;
});
