/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Sun Apr 10 2016 20:47:31 GMT-0700 (PDT).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',    
    'common/util/ejs', // for ejs templates
    'common/util/xmljsonconverter', // used to save model as json
    'plugin/TimingAnalysis/TimingAnalysis/Templates/Templates', // 
    'rosmod/meta',
    'rosmod/remote_utils',
    'rosmod/modelLoader',
    'q'
], function (
    PluginConfig,
    PluginBase,
    ejs,
    Converter,
    TEMPLATES,
    MetaTypes,
    utils,
    loader,
    Q) {
    'use strict';

    /**
     * Initializes a new instance of TimingAnalysis.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin TimingAnalysis.
     * @constructor
     */
    var TimingAnalysis = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
        this.FILES = {
	    'cpn': 'cpn.ejs'
        };
    };

    // Prototypal inheritance from PluginBase.
    TimingAnalysis.prototype = Object.create(PluginBase.prototype);
    TimingAnalysis.prototype.constructor = TimingAnalysis;

    /**
     * Gets the name of the TimingAnalysis.
     * @returns {string} The name of the plugin.
     * @public
     */
    TimingAnalysis.prototype.getName = function () {
        return 'TimingAnalysis';
    };

    /**
     * Gets the semantic version (semver.org) of the TimingAnalysis.
     * @returns {string} The version of the plugin.
     * @public
     */
    TimingAnalysis.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    TimingAnalysis.prototype.getConfigStructure = function() {
        return [
            {
                'name': 'generateCPN',
                'displayName': 'Generate CPN',
                'description': 'Enables generation of CPN-based timing analysis model.',
                'value': true,
                'valueType': 'boolean',
                'readOnly': false
            },
	    {
		'name': 'returnZip',
		'displayName': 'Return generated artifacts.',
		'description': 'If true, it enables the client to download the artifacts.',
		'value': true,
		'valueType': 'boolean',
		'readOnly': false
	    }
        ];
    };

    TimingAnalysis.prototype.notify = function(level, msg) {
	var self = this;
	var prefix = self.projectId + '::' + self.projectName + '::' + level + '::';
	var max_msg_len = 100;
	if (level=='error')
	    self.logger.error(msg);
	else if (level=='debug')
	    self.logger.debug(msg);
	else if (level=='info')
	    self.logger.info(msg);
	else if (level=='warning')
	    self.logger.warn(msg);
	self.createMessage(self.activeNode, msg, level);
	if (msg.length < max_msg_len)
	    self.sendNotification(prefix+msg);
	else {
	    var splitMsgs = utils.chunkString(msg, max_msg_len);
	    splitMsgs.map(function(splitMsg) {
		self.sendNotification(prefix+splitMsg);
	    });
	}
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    TimingAnalysis.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;

        // Default fails
        self.result.success = false;

	// What did the user select for our configuration?
	var currentConfig = self.getCurrentConfig();
	self.generateCPNAnalysis = currentConfig.generateCPN;
	self.returnZip = currentConfig.returnZip;
	self.runningOnClient = false;

	self.artifacts = {};
	
        if (typeof WebGMEGlobal !== 'undefined') {
	    self.runningOnClient = true;
        }
	
        self.updateMETA(self.metaTypes);

	// the active node for this plugin is software -> project
	var projectNode = self.activeNode;
	self.projectName = self.core.getAttribute(projectNode, 'name');

	self.projectModel = {}; // will be filled out by loadProjectModel (and associated functions)

	loader.logger = self.logger;
	utils.logger = self.logger;
      	loader.loadProjectModel(self.core, projectNode)
  	    .then(function (projectModel) {
		self.projectModel = projectModel;
        	return self.generateArtifacts();
  	    })
	    .then(function () {
		return self.saveArtifactsOnServer();
	    })
	    .then(function () {
		return self.returnArtifactsToUser();
	    })
	    .then(function () {
        	self.result.setSuccess(true);
        	callback(null, self.result);
	    })
	    .catch(function (err) {
		self.notify('error', err);
        	self.result.setSuccess(false);
        	callback(err, self.result);
	    })
		.done();
    };

    TimingAnalysis.prototype.generateArtifacts = function() {
	var self = this;
	if ( !self.generateCPNAnalysis ) {
	    return;
	}
	var msg = 'Generating CPN Model.';
	self.notify('info',msg);

	// THIS NEEDS TO BE HEAVILY UPDATED BASED ON NEW STRUCTURE
	for (var dpl in self.projectModel.deployments) {
	    var dpl_model = self.projectModel.deployments[dpl]; 
	    self.createMessage(self.activeNode, 'Parsing Deployment: ' + dpl_model.name);
	    var timer_tokens = '1`[\n';
	    var clock_tokens = '1`[\n';
	    var interaction_tokens = '1`[\n';
	    var component_thread_tokens = '1`[\n';
	    var message_queue_tokens = '1`[\n';
	    var hardware_num = 1

	    var msg_map = {};
	    var srv_map = {};
	    var component_hardware_map = {};

	    for (var c in dpl_model.containers) {
		var container = dpl_model.containers[c];
		for (var n in container.nodes) {
		    var node = container.nodes[n];
		    for (var ci in node.compInstances) {
			var compInstance = node.compInstances[ci];
			var component = compInstance.component;
			component_hardware_map[component.name] = "CPU_" + hardware_num;
		    }
		}
		hardware_num += 1;
	    }
	    hardware_num = 1;
	    for (var c in dpl_model.containers) {
		var container = dpl_model.containers[c];
		for (var n in container.nodes) {
		    var node = container.nodes[n];
		    for (var ci in node.compInstances) {
			var compInstance = node.compInstances[ci];
			var component = compInstance.component;
			for (var p in component.publishers) {
			    var publisher = component.publishers[p];
			    publisher.component = component.name;
			    var msg = publisher.topic.name;
			    if (!msg_map[msg]) {
				msg_map[msg] = {
				    publishers: [],
				    subscribers: []
				};
			    }
			    msg_map[msg].publishers.push(publisher);
			}
			for (var s in component.subscribers) {
			    var subscriber = component.subscribers[s];
			    subscriber.component = component.name;
			    var msg = subscriber.topic.name;
			    if (!msg_map[msg]) {
				msg_map[msg] = {
				    publishers: [],
				    subscribers: []
				};
			    }
			    msg_map[msg].subscribers.push(subscriber);
			}
			for (var c in component.clients) {
			    var client = component.clients[c];
			    client.component = component.name;
			    var srv = client.service.name;
			    if (!srv_map[srv]) {
				srv_map[srv] = {
				    clients : [],
				    servers : []
				};
			    }
			    srv_map[srv].clients.push(client);
			}
			for (var s in component.servers) {
			    var server = component.servers[s];
			    server.component = component.name;
			    var srv = server.service.name;
			    if (!srv_map[srv]) {
				srv_map[srv] = {
				    clients : [],
				    servers : []
				};
			    }
			    srv_map[srv].servers.push(server);
			}
		    }
		}
	    }

	    for (var c in dpl_model.containers) {
		var container = dpl_model.containers[c];

		// Clock Tokens check
		if (clock_tokens != '1`[\n') {
		    clock_tokens += ',\n';
		}
		clock_tokens += '{node="CPU_' + hardware_num.toString() 
		    + '", value=0, next_tick=4000}';

		// Component Thread Tokens check
		if (component_thread_tokens != '1`[\n') {
		    component_thread_tokens += ',\n';
		}
		component_thread_tokens += '{node="CPU_' + hardware_num.toString() + '", threads=[';

		// Component Message Queue Tokens check
		if (message_queue_tokens != '1`[\n') {
		    message_queue_tokens += ',\n';
		}
		// 1`[{node=&quot;BBB_111&quot;, cmql=[{component=&quot;Component_1&quot;, scheme=PFIFO, queue=[]}]}]
		message_queue_tokens += '{node="CPU_' + hardware_num.toString() + '", cmql=[';
		
		for (var n in container.nodes) {
		    var node = container.nodes[n];
		    var node_priority = node.priority;

		    for (var ci in node.compInstances) {
			var compInstance = node.compInstances[ci];
			var component = compInstance.component;
			if (component_thread_tokens.slice(-1) != '[')
			    component_thread_tokens += ', ';
			component_thread_tokens += '{node="CPU_' + hardware_num.toString() + 
			    '", component="' + component.name + '", priority=' + node_priority + ', operation=[]}';

			if (message_queue_tokens.slice(-1) != '[')
			    message_queue_tokens += ', ';
			message_queue_tokens += '{component="' + component.name 
			    + '", scheme=' + compInstance.schedulingScheme + ', queue=[]}';
		    }

		    for (var ci in node.compInstances) {
			var compInstance = node.compInstances[ci];
			var component = compInstance.component;

			for (var t in component.timers) {
			    var timer = component.timers[t];
			    // Timer Tokens check
			    if (timer_tokens != '1`[\n') {
				timer_tokens += ',\n';
			    }
			    timer_tokens += '{node="CPU_' + hardware_num.toString() + 
				'", period=' + timer.period * 1000000 + ', offset=0, operation=' +
				'{node="CPU_' + hardware_num.toString() + '", component="' +
				component.name + '", operation="' + timer.name + '_operation"' + 
				', priority=' + timer.priority + ', deadline=' + 
				timer.deadline * 1000000 + ', enqueue_time=0, steps=[';
			    var re = /([A-Z]*)\s([\w\_\.\(\)]+);/g;
			    var result = re.exec(timer.abstractBusinessLogic);
			    while(result != null) {
				var port_type = result[1];
				var wcet = 0;
				if (port_type == "LOCAL") {
				    var wcet = result[2];
				    if (timer_tokens.slice(-1) != '[')
					timer_tokens += ', ';
				    timer_tokens += '{kind="LOCAL", port="LOCAL", unblk=[], exec_time=0, duration=' + wcet * 1000000 + '}';
				}
				else if (port_type == "RMI") {
				    if (timer_tokens.slice(-1) != '[')
					timer_tokens += ', ';
				    timer_tokens += '{kind="CLIENT", port="' + result[2] + '", unblk=[], exec_time=0, duration=0}';
				}
				else if (port_type == "PUBLISH") {
				    if (timer_tokens.slice(-1) != '[')
					timer_tokens += ', ';
				    timer_tokens += '{kind="PUBLISHER", port="' + result[2] + '", unblk=[], exec_time=0, duration=0}';
				}
				result = re.exec(timer.abstractBusinessLogic);
			    }
			    timer_tokens += ']}}';
			}

			for (var p in component.publishers) {
			    var publisher = component.publishers[p];
			    var topic = publisher.topic.name;
			    var subscribers = msg_map[topic].subscribers;
			    for (var s in subscribers) {
				var subscriber = subscribers[s];
				if (interaction_tokens != '1`[\n') {
				    interaction_tokens += ',\n';
				}
				interaction_tokens += '{node="CPU_' + hardware_num.toString() + 
				    '", port="' + publisher.name + '", operation={node="' + component_hardware_map[subscriber.component] + '", component="' + 
				    subscriber.component + '", operation="' + subscriber.name + '_operation", priority=' + subscriber.priority + ', deadline=' + 
				    subscriber.deadline * 1000000 + ', enqueue_time=0, steps=[';
				var re = /([A-Z]*)\s([\w\_\.\(\)]+);/g;
				var result = re.exec(subscriber.abstractBusinessLogic);
				while(result != null) {
				    var port_type = result[1];
				    var wcet = 0;
				    if (port_type == "LOCAL") {
					var wcet = result[2];
					if (interaction_tokens.slice(-1) != '[')
					    interaction_tokens += ', ';
					interaction_tokens += '{kind="LOCAL", port="LOCAL", unblk=[], exec_time=0, duration=' + wcet * 1000000 + '}';
				    }
				    else if (port_type == "RMI") {
					if (interaction_tokens.slice(-1) != '[')
					    interaction_tokens += ', ';
					interaction_tokens += '{kind="CLIENT", port="' + result[2] + '", unblk=[], exec_time=0, duration=0}';
				    }
				    else if (port_type == "PUBLISH") {
					if (interaction_tokens.slice(-1) != '[')
					    interaction_tokens += ', ';
					interaction_tokens += '{kind="PUBLISHER", port="' + result[2] + '", unblk=[], exec_time=0, duration=0}';
				    }
				    result = re.exec(subscriber.abstractBusinessLogic);
				}
				interaction_tokens += ']}}';
			    }
			}

			for (var c in component.clients) {
			    var client = component.clients[c];
			    var service = client.service.name;
			    var servers = srv_map[service].servers;
			    for (var s in servers) {
				var server = servers[s];
				if (interaction_tokens != '1`[\n') {
				    interaction_tokens += ',\n';
				}
				interaction_tokens += '{node="CPU_' + hardware_num.toString() + 
				    '", port="' + client.name + '", operation={node="' + component_hardware_map[server.component] + '", component="' + 
				    server.component + '", operation="' + server.name + '_operation", priority=' + server.priority + ', deadline=' + 
				    server.deadline * 1000000 + ', enqueue_time=0, steps=[';
				var re = /([A-Z]*)\s([\w\_\.\(\)]+);/g;
				var result = re.exec(server.abstractBusinessLogic);
				while(result != null) {
				    var port_type = result[1];
				    var wcet = 0;
				    if (port_type == "LOCAL") {
					var wcet = result[2];
					if (interaction_tokens.slice(-1) != '[')
					    interaction_tokens += ', ';
					interaction_tokens += '{kind="LOCAL", port="LOCAL", unblk=[], exec_time=0, duration=' + wcet * 1000000 + '}';
				    }
				    else if (port_type == "RMI") {
					if (interaction_tokens.slice(-1) != '[')
					    interaction_tokens += ', ';
					interaction_tokens += '{kind="CLIENT", port="' + result[2] + '", unblk=[], exec_time=0, duration=0}';
				    }
				    else if (port_type == "PUBLISH") {
					if (interaction_tokens.slice(-1) != '[')
					    interaction_tokens += ', ';
					interaction_tokens += '{kind="PUBLISHER", port="' + result[2] + '", unblk=[], exec_time=0, duration=0}';
				    }					    
				    result = re.exec(server.abstractBusinessLogic);
				}
				var n = interaction_tokens.lastIndexOf("unblk=[]");
				interaction_tokens = interaction_tokens.slice(0, n) + interaction_tokens.slice(n).replace("unblk=[]", 'unblk=[{node="CPU_' +  
															  hardware_num.toString() + '", component="' + 
															  component.name  + '", port="' + client.name  + '"}]');
				interaction_tokens += ']}}';
			    }
			}

		    }
		}
		component_thread_tokens += ']}';
		message_queue_tokens += ']}';
		hardware_num += 1
	    }
	    clock_tokens += '\n]';
	    timer_tokens += '\n]';
	    interaction_tokens += '\n]';
	    component_thread_tokens += '\n]';
	    message_queue_tokens += '\n]';

	    var cpn = dpl_model.name + '_Analysis_Model.cpn',
	    cpnTemplate = TEMPLATES[self.FILES['cpn']];
	    self.artifacts[cpn] = ejs.render(cpnTemplate, {'clock_tokens' : clock_tokens, 
							   'timer_tokens' : timer_tokens,
							   'interaction_tokens' : interaction_tokens,
							   'component_thread_tokens' : component_thread_tokens,
							   'message_queue_tokens' : message_queue_tokens});
	}
    };

    TimingAnalysis.prototype.saveArtifactsOnServer = function() {
	var self = this;
	if ( self.runningOnClient ) {
	    return;
	}
	var path = require('path');

	// Setting up variables that will be used by various functions of this plugin
	self.gen_dir = path.join(process.cwd(),
				 'generated',
				 self.project.projectId,
				 self.branchName,
				 self.projectName);
	var prefix = path.join(self.gen_dir,'cpn');

	// Get the dummy cpn template
	var file_url = 'https://github.com/rosmod/rosmod-cpn/releases/download/v1.0.0/cpn.zip';
	var dir = prefix;
	return utils.wgetAndUnzipLibrary(file_url, dir)
	    .then(function() {
		self.createMessage(self.activeNode, 'Downloaded CPN template');
	    })
	    .then(function() {
		var filendir = require('filendir');
		var fileKeys = Object.keys(self.artifacts);
		var tasks = fileKeys.map(function(key) {
		    var fname = path.join(prefix, key),
		    data = self.artifacts[key];

		    return new Promise(function(resolve, reject) {
			filendir.writeFile(fname, data, function(err) {
			    if (err) {
				self.logger.error(err);
				reject(err);
			    }
			    else {
				resolve();
			    }
			});
		    });
		});
		return Q.all(tasks);
	    })
	    .then(function() {
		var msg = 'Generated CPN';
		self.notify('info', msg);
	    })
    };

    TimingAnalysis.prototype.returnArtifactsToUser = function() {
	var self = this;
	if (!self.returnZip) {
	    self.notify('info', 'User did not request the artifacts to be returned.');
	    return;
	}
	
	self.notify('info', 'Returning artifacts to user.');

	var fileNames = Object.keys(self.artifacts);

	var tasks = fileNames.map(function(fileName) {
	    return self.blobClient.putFile(fileName, self.artifacts[fileName])
		.then(function (hash) {
		    self.result.addArtifact(hash);
		});
	});

	return Q.all(tasks);
    };

    return TimingAnalysis;
});
